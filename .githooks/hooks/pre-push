#!/bin/bash
# Pre-push Hook for Home Lab Inventory Project
# Comprehensive validation before pushing to remote repository

set -euo pipefail

# Configuration
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly UTILS_DIR="$(dirname "$SCRIPT_DIR")/utils"
readonly HOOK_NAME="pre-push"

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly NC='\033[0m' # No Color

# Global state
EXIT_CODE=0
TOTAL_CHECKS=0
PASSED_CHECKS=0

# Remote and local refs (passed by git)
REMOTE=""
REMOTE_URL=""

# Helper functions
print_error() {
    echo -e "${RED}‚ùå ERROR: $1${NC}" >&2
}

print_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è  WARNING: $1${NC}"
}

print_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

print_info() {
    echo -e "${BLUE}‚ÑπÔ∏è  $1${NC}"
}

print_step() {
    echo -e "${CYAN}üîÑ $1${NC}"
}

print_header() {
    echo -e "${PURPLE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
    echo -e "${PURPLE} Pre-push Hook: $1${NC}"
    echo -e "${PURPLE}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
}

# Track check results
track_check() {
    local check_name="$1"
    local status="$2"

    ((TOTAL_CHECKS++))

    if [[ "$status" == "0" ]]; then
        ((PASSED_CHECKS++))
        print_success "$check_name passed"
    else
        print_error "$check_name failed"
        EXIT_CODE=1
    fi
}

# Get list of commits being pushed
get_commits_being_pushed() {
    local remote_ref="$1"
    local local_ref="$2"

    if [[ "$remote_ref" == "0000000000000000000000000000000000000000" ]]; then
        # New branch, get all commits
        git rev-list "$local_ref"
    else
        # Existing branch, get new commits
        git rev-list "$remote_ref..$local_ref"
    fi
}

# Validate commit messages in range
validate_commit_messages_range() {
    local commits="$1"

    print_step "Validating commit messages for pushed commits..."

    if [[ -z "$commits" ]]; then
        print_info "No commits to validate"
        track_check "Commit message validation" "0"
        return 0
    fi

    local failed_commits=()
    local total_commits=0

    while IFS= read -r commit; do
        [[ -z "$commit" ]] && continue
        ((total_commits++))

        # Get commit message
        local commit_msg
        commit_msg=$(git log --format=%B -n 1 "$commit")

        # Create temporary file for validation
        local temp_file
        temp_file=$(mktemp)
        echo "$commit_msg" > "$temp_file"

        # Validate using our conventional commits validator
        local validation_result=0
        if [[ -x "$UTILS_DIR/conventional-commits.sh" ]]; then
            if ! "$UTILS_DIR/conventional-commits.sh" --quiet "$temp_file"; then
                failed_commits+=("$commit")
                validation_result=1
            fi
        else
            # Basic validation
            local subject_line
            subject_line=$(echo "$commit_msg" | head -n1)

            if [[ ! "$subject_line" =~ ^[a-z]+(\([a-z0-9-]+\))?\!?:[[:space:]]*[a-z] ]]; then
                failed_commits+=("$commit")
                validation_result=1
            fi
        fi

        rm -f "$temp_file"

        if [[ $validation_result -ne 0 ]]; then
            print_error "Invalid commit message in $commit:"
            git log --format="  %s" -n 1 "$commit"
        fi

    done <<< "$commits"

    if [[ ${#failed_commits[@]} -gt 0 ]]; then
        print_error "${#failed_commits[@]} out of $total_commits commits have invalid messages"
        track_check "Commit message validation" "1"
        return 1
    else
        print_info "All $total_commits commit messages are valid"
        track_check "Commit message validation" "0"
        return 0
    fi
}

# Check for secrets in pushed commits
check_secrets_in_commits() {
    local commits="$1"

    print_step "Scanning pushed commits for secrets..."

    if [[ -z "$commits" ]]; then
        print_info "No commits to scan"
        track_check "Secret scanning" "0"
        return 0
    fi

    local result=0
    local temp_dir
    temp_dir=$(mktemp -d)

    # Extract all changed files from the commits
    while IFS= read -r commit; do
        [[ -z "$commit" ]] && continue

        # Get files changed in this commit
        git diff-tree --no-commit-id --name-only -r "$commit" | while IFS= read -r file; do
            if [[ -n "$file" ]] && git cat-file -e "$commit:$file" 2>/dev/null; then
                # Create directory structure
                local file_dir
                file_dir=$(dirname "$temp_dir/$file")
                mkdir -p "$file_dir"

                # Extract file content at this commit
                git show "$commit:$file" > "$temp_dir/$file" 2>/dev/null || continue
            fi
        done

    done <<< "$commits"

    # Scan extracted files
    if [[ -n "$(find "$temp_dir" -type f 2>/dev/null)" ]]; then
        if [[ -x "$UTILS_DIR/secret-detector.sh" ]]; then
            if ! find "$temp_dir" -type f -exec "$UTILS_DIR/secret-detector.sh" --strict --quiet {} +; then
                result=1
            fi
        else
            print_warning "Secret detector not available"
        fi
    fi

    # Cleanup
    rm -rf "$temp_dir"

    track_check "Secret scanning" "$result"
    return $result
}

# Validate GitHub workflow files
validate_github_workflows() {
    print_step "Validating GitHub workflow files..."

    # Check if .github/workflows directory exists and has files
    if [[ ! -d ".github/workflows" ]]; then
        print_info "No GitHub workflows to validate"
        track_check "GitHub workflow validation" "0"
        return 0
    fi

    local workflow_files
    workflow_files=$(find .github/workflows -name "*.yml" -o -name "*.yaml" 2>/dev/null || true)

    if [[ -z "$workflow_files" ]]; then
        print_info "No GitHub workflow files found"
        track_check "GitHub workflow validation" "0"
        return 0
    fi

    local result=0
    if [[ -x "$UTILS_DIR/yaml-validator.py" ]]; then
        if ! echo "$workflow_files" | xargs "$UTILS_DIR/yaml-validator.py" --github-workflows --quiet; then
            result=1
        fi
    else
        print_warning "YAML validator not available"
    fi

    track_check "GitHub workflow validation" "$result"
    return $result
}

# Check Docker Compose files
validate_docker_compose() {
    print_step "Validating Docker Compose files..."

    local compose_files
    compose_files=$(find . -name "docker-compose*.yml" -o -name "docker-compose*.yaml" 2>/dev/null || true)

    if [[ -z "$compose_files" ]]; then
        print_info "No Docker Compose files to validate"
        track_check "Docker Compose validation" "0"
        return 0
    fi

    local result=0

    # YAML syntax validation
    if [[ -x "$UTILS_DIR/yaml-validator.py" ]]; then
        if ! echo "$compose_files" | xargs "$UTILS_DIR/yaml-validator.py" --docker-compose --quiet; then
            result=1
        fi
    fi

    # Docker Compose validation (if docker is available)
    if command -v docker >/dev/null 2>&1; then
        while IFS= read -r file; do
            [[ -z "$file" ]] && continue

            print_info "Validating Docker Compose syntax: $file"
            if ! docker compose -f "$file" config >/dev/null 2>&1; then
                print_error "Docker Compose validation failed for: $file"
                result=1
            fi
        done <<< "$compose_files"
    else
        print_warning "Docker not available - skipping compose validation"
    fi

    track_check "Docker Compose validation" "$result"
    return $result
}

# Check branch protection rules
check_branch_protection() {
    local local_ref="$1"
    local branch_name
    branch_name=$(echo "$local_ref" | sed 's|refs/heads/||')

    print_step "Checking branch protection rules..."

    # Check if pushing to protected branches
    case "$branch_name" in
        main|master|production|prod)
            print_warning "Pushing to protected branch: $branch_name"
            print_info "Ensure you have proper authorization"
            ;;
        *)
            print_info "Pushing to branch: $branch_name"
            ;;
    esac

    track_check "Branch protection check" "0"
    return 0
}

# Run comprehensive tests
run_tests() {
    print_step "Running available tests..."

    local result=0

    # Check for test scripts
    if [[ -f "Makefile" ]] && grep -q "test:" Makefile; then
        print_info "Running make test..."
        if ! make test; then
            result=1
        fi
    elif [[ -f "package.json" ]] && grep -q "\"test\"" package.json; then
        print_info "Running npm test..."
        if ! npm test; then
            result=1
        fi
    elif [[ -f "pyproject.toml" ]] || [[ -f "requirements.txt" ]]; then
        print_info "Looking for Python tests..."
        if [[ -d "tests" ]] || [[ -d "test" ]]; then
            if command -v pytest >/dev/null 2>&1; then
                if ! pytest; then
                    result=1
                fi
            elif command -v python >/dev/null 2>&1; then
                if ! python -m unittest discover; then
                    result=1
                fi
            fi
        else
            print_info "No Python test directory found"
        fi
    else
        print_info "No test framework detected"
    fi

    track_check "Test execution" "$result"
    return $result
}

# Check repository status
check_repository_status() {
    print_step "Checking repository status..."

    local result=0

    # Check for uncommitted changes
    if ! git diff --quiet; then
        print_warning "Uncommitted changes detected"
        git status --short | head -10
        print_info "Consider committing or stashing changes"
    fi

    # Check for untracked files
    local untracked_files
    untracked_files=$(git ls-files --others --exclude-standard)
    if [[ -n "$untracked_files" ]]; then
        print_info "Untracked files detected:"
        echo "$untracked_files" | head -5
    fi

    track_check "Repository status" "$result"
    return $result
}

# Main execution
main() {
    # Parse git pre-push arguments
    REMOTE="$1"
    REMOTE_URL="$2"

    print_header "Home Lab Inventory Push Validation"
    print_info "Remote: $REMOTE"
    print_info "URL: $REMOTE_URL"
    echo

    # Read refs from stdin
    local refs_processed=0
    while IFS=' ' read -r local_ref local_oid remote_ref remote_oid; do
        [[ -z "$local_ref" ]] && continue

        ((refs_processed++))

        print_info "Processing ref: $local_ref -> $remote_ref"

        # Skip deleted refs
        if [[ "$local_oid" == "0000000000000000000000000000000000000000" ]]; then
            print_info "Deleting ref $remote_ref - skipping validation"
            continue
        fi

        # Get commits being pushed
        local commits
        commits=$(get_commits_being_pushed "$remote_oid" "$local_oid")

        if [[ -n "$commits" ]]; then
            local commit_count
            commit_count=$(echo "$commits" | wc -l)
            print_info "Found $commit_count commits to push"
        fi

        echo

        # Run validations
        validate_commit_messages_range "$commits"
        echo

        check_secrets_in_commits "$commits"
        echo

        check_branch_protection "$local_ref"
        echo
    done

    if [[ $refs_processed -eq 0 ]]; then
        print_info "No refs to process"
        exit 0
    fi

    # Repository-wide checks
    check_repository_status
    echo

    validate_github_workflows
    echo

    validate_docker_compose
    echo

    # Run tests (optional - can be disabled if too slow)
    if [[ "${SKIP_TESTS:-false}" != "true" ]]; then
        run_tests
        echo
    else
        print_info "Tests skipped (SKIP_TESTS=true)"
        track_check "Test execution" "0"
    fi

    # Final summary
    print_header "Push Validation Summary"
    echo
    print_info "Checks run: $TOTAL_CHECKS"
    print_info "Checks passed: $PASSED_CHECKS"
    print_info "Checks failed: $((TOTAL_CHECKS - PASSED_CHECKS))"
    echo

    if [[ $EXIT_CODE -eq 0 ]]; then
        print_success "All pre-push checks passed! üöÄ"
        print_info "Push is ready to proceed"
    else
        print_error "Pre-push validation failed! ‚ùå"
        print_info "Please fix the issues above and try again"
        echo
        print_info "To skip these checks temporarily, use:"
        print_info "  git push --no-verify"
        print_warning "WARNING: Skipping checks may introduce issues to the remote repository"
        echo
        print_info "To skip only tests, use:"
        print_info "  SKIP_TESTS=true git push"
    fi

    exit $EXIT_CODE
}

# Run main function
main "$@"
